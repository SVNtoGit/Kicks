default namespace = ""
namespace xsi = "http://www.w3.org/2001/XMLSchema-instance"
# Original contribution by chinajade

# MAINTAINER'S NOTE:
# Using RelaxNG to validate Condition/TerminateWhen/etc is pushing
# the very limits of the schema definition capabilities.
# However, we provide enough here to eliminate many of the common mistakes
# This is not true EBNF.  Thus, it has limitations:
# * It can't take into account all parenthesis possibilities
# * Parentheses must be separated from encompasing terms by a space
# * The type checking is not as strict as we like.
#   For instance "Me.Class != HasAura(123)" will not be detected
#   as the failure it should be.
#
# On the up side, it does check for a *lot* of common profile mistakes
# * Term misspellings
#   E.g., IsQuestComplete instead of IsQuestCompleted
# * Appropriate number of arguments for helper methods
#   It also checks for appropriate argument types in most situations.
# * Proper capitalization and spelling of Terms (methods, arguments, etc)
# * etc


# ----------
BinaryEquality = xsd:token { pattern="(==)|(!=)" }
BinaryConjunction = xsd:token { pattern="(\|\|)|(&&)" }
BinaryCompare = xsd:token { pattern="(<)|(<=)|(>)|(>=)" }

BinaryOp =
  BinaryEquality
  | BinaryConjunction
  | BinaryCompare

LParen = xsd:token { pattern="\(" }
RParen = xsd:token { pattern="\)" }


# ----------

# CanFly
Term |= xsd:token { pattern="!?CanFly\(\)" }

# Chance
Term |= xsd:token { pattern="!?Chance\((100\|[1-9][0-9]\|[1-9]\|0)\.?[0-9]*\)" }

# Class
Term |= xsd:token { pattern="Me\.Class" }
Term |= xsd:token { pattern="WoWClass\.DeathKnight" }
Term |= xsd:token { pattern="WoWClass\.Druid" }
Term |= xsd:token { pattern="WoWClass\.Hunter" }
Term |= xsd:token { pattern="WoWClass\.Mage" }
Term |= xsd:token { pattern="WoWClass\.Monk" }
Term |= xsd:token { pattern="WoWClass\.Paladin" }
Term |= xsd:token { pattern="WoWClass\.Priest" }
Term |= xsd:token { pattern="WoWClass\.Rogue" }
Term |= xsd:token { pattern="WoWClass\.Shaman" }
Term |= xsd:token { pattern="WoWClass\.Warlock" }
Term |= xsd:token { pattern="WoWClass\.Warrior" }

# Coin
Term |= xsd:token { pattern="Me\.(Copper|Gold|Silver)" }
Term |= xsd:token { pattern="GetCurrencyAmount\([0-9]+\)" }

# Distance
Term |= xsd:token { pattern="DistanceToUnit\([0-9]+\.?[0-9]*\)" }

# Faction
Term |= xsd:token { pattern="!?Me\.(IsAlliance|IsHorde)" }
Term |= xsd:token { pattern="GetFactionReputation\([0-9]+\)" }

# Items
Term |= xsd:token { pattern="GetItemCount\([0-9]+\)" }

# Has*
Term |= xsd:token { pattern="!?Me\.HasAura\([0-9]+\)" }
Term |= xsd:token { pattern="""!?Me\.HasAura\("[^"]+"\)""" }
Term |= xsd:token { pattern="!?HasFaction\([0-9]+\)" }
Term |= xsd:token { pattern="!?HasItem\([0-9]+\)" }
Term |= xsd:token { pattern="!?HasMinion\([0-9]+\)" }
Term |= xsd:token { pattern="!?HasQuest\([0-9]+\)" }
Term |= xsd:token { pattern="!?HasQuestAvailable\([0-9]+\)" }
Term |= xsd:token { pattern="!?HasSpell\([0-9]+\)" }
Term |= xsd:token { pattern="""!?HasSpell\("[^"]+"\)""" }

# Hearthstone
Term |= xsd:token { pattern="Me\.HearthstoneAreaId" }
Term |= xsd:token { pattern="Me\.MapId" }
Term |= xsd:token { pattern="Me\.ZoneId" }

# Is*
Term |= xsd:token { pattern="!?IsAchievementComplete\([0-9]+\)" }
## Unfortunately, we cannot allow spaces between the IsObjectiveComplete
## arguments due to the lexical tokenization of 'list'.
Term |= xsd:token { pattern="!?IsAchievementComplete\([0-9]+,[0-9]+\)" }
Term |= xsd:token { pattern="!?Me\.IsOnTransport" }
Term |= xsd:token { pattern="!?IsQuestCompleted\([0-9]+\)" }
## Unfortunately, we cannot allow spaces between the IsObjectiveComplete
## arguments due to the lexical tokenization of 'list'.
Term |= xsd:string { pattern="!?IsObjectiveComplete\([1-9],[0-9]+\)" }

# Level
Term |= xsd:token { pattern="Me\.Level" }

# Location
Term |= xsd:token { pattern="Me\.[XYZ]" }

# Navigation
# CanNavigateFully will work as a stand-alone Term, but will be flagged
# in as an error when used in a Binary expression or greater.  This is because
# the mandatory space between "new WoWPoint" will throw off the schema lexer
# when trying to process a 'list'.
Term |= xsd:token { pattern="Navigator\.CanNavigateFully\(Me\.Location,\s*new WoWPoint\((\s*[+\-]?[0-9]+\.?[0-9]*),(\s*[+\-]?[0-9]+\.?[0-9]*),(\s*[+\-]?[0-9]+\.?[0-9]*)\)\)" }
Term |= xsd:token { pattern="OnTransport" }

# Race
Term |= xsd:token { pattern="Me\.Race" }
Term |= xsd:token { pattern="WoWRace\.Draenei" }
Term |= xsd:token { pattern="WoWRace\.Dwarf" }
Term |= xsd:token { pattern="WoWRace\.Gnome" }
Term |= xsd:token { pattern="WoWRace\.Human" }
Term |= xsd:token { pattern="WoWRace\.NightElf" }
Term |= xsd:token { pattern="WoWRace\.Pandaren" }
Term |= xsd:token { pattern="WoWRace\.Worgen" }

Term |= xsd:token { pattern="WoWRace\.BloodElf" }
Term |= xsd:token { pattern="WoWRace\.Goblin" }
Term |= xsd:token { pattern="WoWRace\.Orc" }
Term |= xsd:token { pattern="WoWRace\.Tauren" }
Term |= xsd:token { pattern="WoWRace\.Troll" }
Term |= xsd:token { pattern="WoWRace\.Undead" }

Term |= xsd:token { pattern="WoWRace\.Broken" }
Term |= xsd:token { pattern="WoWRace\.FelOrc" }
Term |= xsd:token { pattern="WoWRace\.ForestTroll" }
Term |= xsd:token { pattern="WoWRace\.IceTroll" }
Term |= xsd:token { pattern="WoWRace\.Naga" }
Term |= xsd:token { pattern="WoWRace\.NorthrendSkeleton" }
Term |= xsd:token { pattern="WoWRace\.Skeleton" }
Term |= xsd:token { pattern="WoWRace\.Taunka" }
Term |= xsd:token { pattern="WoWRace\.Tuskarr" }
Term |= xsd:token { pattern="WoWRace\.Vrykul" }

# Reputation
Term |= xsd:token { pattern="Me\.GetReputationLevelWith\([0-9]+\)" }
Term |= xsd:token { pattern="Styx\.WoWUnitReaction\.Exalted" }
Term |= xsd:token { pattern="Styx\.WoWUnitReaction\.Friendly" }
Term |= xsd:token { pattern="Styx\.WoWUnitReaction\.Hated" }
Term |= xsd:token { pattern="Styx\.WoWUnitReaction\.Honored" }
Term |= xsd:token { pattern="Styx\.WoWUnitReaction\.Hostile" }
Term |= xsd:token { pattern="Styx\.WoWUnitReaction\.Neutral" }
Term |= xsd:token { pattern="Styx\.WoWUnitReaction\.Revered" }
Term |= xsd:token { pattern="Styx\.WoWUnitReaction\.Unfriendly" }

# Selection
Term |= xsd:token { pattern="Object\([0-9]+\)" }
## Unfortunately, we cannot allow spaces between the IsObjectiveComplete
## arguments due to the lexical tokenization of 'list'.
Term |= xsd:token { pattern="Object\([0-9]+,.*\)" }
Term |= xsd:token { pattern="Unit\([0-9]+\)" }
## Unfortunately, we cannot allow spaces between the IsObjectiveComplete
## arguments due to the lexical tokenization of 'list'.
Term |= xsd:token { pattern="Unit\([0-9]+,.*\)" }

# Skill
Term |= xsd:token { pattern="Me\.GetSkill\(Styx\.SkillLine\.Riding\)(\.CurrentValue)?" }
Term |= xsd:token { pattern="HerbalismSkill" }
Term |= xsd:token { pattern="MiningSkill" }
Term |= xsd:token { pattern="SkinningSkill" }

# Constant Numerics
Term |= HBType-MapId
Term |= xsd:decimal
Term |= xsd:token { pattern="null" }

# ********** Expressions **********
# We could reduce all these expressions down to BinaryOp, and
# leave BinaryConjunction out.  However, that would fail to catch
# many common profile writer mistakes.  So, we go the extra mile here.
#
# Each Expression type starts with the general all-conjunction expression.
# Then, the first block contains permutations of one BinaryOp expression.
# The next block permutations of two BinaryOp expressions.  Etc.
#
# We stop the general Expression expansion at 6 Terms.  Anything larger than that
# will be handled as special cases.  It would be soooo nice if this were
# true EBNF, so we could really do the job well.  However, we're
# incredibly happy that RelaxNG has even this much built-in power already.

Expression =
  Expression1Term
  | Expression2Terms
  | Expression3Terms
  | Expression4Terms
  | Expression5Terms
  | Expression6Terms
  | ExpressionSpecialCaseTerms

Expression1Term =
  Term
  | list { LParen, Term, RParen }

Expression2Terms =
  # a < b
  list { Term, BinaryOp, Term }
  # ( a < b )
  | list { LParen, Term, BinaryOp, Term, RParen }

Expression3Terms =
  # General case...
  # a || b || c
  list { Term, BinaryConjunction, Term, BinaryConjunction, Term }

  # Permutations with one BinaryOp sub-expression...
  # a < b || c
  | list { Term, BinaryOp, Term, BinaryConjunction, Term }
  # ( a < b ) || c
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term }
  # a || b < c
  | list { Term, BinaryConjunction, Term, BinaryOp, Term }
  # a || ( b < c )
  | list { Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }

Expression4Terms =
  # General case...
  # a || b || c || d
  list { Term, BinaryConjunction, Term, RParen, BinaryConjunction, LParen, Term, BinaryConjunction, Term }

  # Permutations with one BinaryOp sub-expression...
  # a < b || c || d
  | list { Term, BinaryOp, Term, BinaryConjunction, Term, BinaryConjunction, Term }
  # ( a < b ) || c || d
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryConjunction, Term }
  # a || b < c || d
  | list { Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term }
  # a || ( b < c ) || d
  | list { Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term }
  # a || b || c < d
  | list { Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryOp, Term }
  # a || b || ( c < d )
  | list { Term, BinaryConjunction, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }
  
  # Permutations with two BinaryOp sub-expressions...
  # a < b || c < d
  | list { Term, BinaryOp, Term, BinaryConjunction, Term, BinaryOp, Term }
  # a < b || ( c < d )
  | list { Term, BinaryOp, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }
  # ( a < b ) || c < d
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryOp, Term }
  # ( a < b ) || ( c < d )
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }

Expression5Terms =
  # General case...
  # a || b || c || d || e
  list { Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term }

  # Permutations with one BinaryOp expression...
  # a < b || c || d || e
  | list { Term, BinaryOp, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term }
  # ( a < b ) || c || d || e
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term }
  # a || b < c || d || e
  | list { Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term, BinaryConjunction, Term }
  # a || ( b < c ) || d || e
  | list { Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryConjunction, Term }
  # a || b || c < d || e
  | list { Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term }
  # a || b || ( c < d ) || e
  | list { Term, BinaryConjunction, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term }
  # a || b || c || d < e
  | list { Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryOp, Term }
  # a || b || c || ( d < e )
  | list { Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }

  # Permutations with two BinaryOp expressions...
  # a < b || c < d || e
  | list { Term, BinaryOp, Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term }
  # ( a < b ) || c < d || e
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term }
  # a < b || ( c < d ) || e
  | list { Term, BinaryOp, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term }
  # ( a < b ) || ( c < d ) || e
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term }
  # a || b < c || d < e
  | list { Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term, BinaryOp, Term }
  # a || ( b < c ) || d < e
  | list { Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryOp, Term }
  # a || b < c || ( d < e )
  | list { Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }
  # a || ( b < c ) || ( d < e )
  | list { Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }

Expression6Terms =
  # General case...
  # a || b || c || d || e || f
  list { Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term }

  # Permutations with one BinaryOp expression...
  # a < b || c || d || e || f
  | list { Term, BinaryOp, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term }
  # ( a < b ) || c || d || e || f
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term }
  # a || b < c || d || e || f
  | list { Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term }
  # a || ( b < c ) || d || e || f
  | list { Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term }
  # a || b || c < d || e || f
  | list { Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term, BinaryConjunction, Term }
  # a || b || ( c < d || e || f
  | list { Term, BinaryConjunction, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryConjunction, Term }
  # a || b || c || d < e || f
  | list { Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term }
  # a || b || c || ( d < e ) || f
  | list { Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term }
  # a || b || c || d || e < f
  | list { Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryOp, Term }
  # a || b || c || d || ( e < f )
  | list { Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }

  # Permutations with two BinaryOp expressions...
  # a < b || c < d || e || f
  | list { Term, BinaryOp, Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term, BinaryConjunction, Term }
  # ( a < b ) || c < d || e || f
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term, BinaryConjunction, Term }
  # a < b || ( c < d ) || e || f
  | list { Term, BinaryOp, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryConjunction, Term }
  # ( a < b ) || ( c < d ) || e || f
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryConjunction, Term }

  # a < b || c || d || e < f
  | list { Term, BinaryOp, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryOp, Term }
  # ( a < b ) || c || d || e < f
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryOp, Term }
  # a < b || c || d || ( e < f )
  | list { Term, BinaryOp, Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }
  # ( a < b ) || c || d || ( e < f )
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryConjunction, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }

  # a || b || c < d || e < f
  | list { Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term, BinaryOp, Term }
  # a || b || ( c < d ) || e < f
  | list { Term, BinaryConjunction, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryOp, Term }
  # a || b || c < d || ( e < f )
  | list { Term, BinaryConjunction, Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }
  # a || b || ( c < d ) || ( e < f )
  | list { Term, BinaryConjunction, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }

  # Permutations with three BinaryOp expressions...
  # a < b || c < d || e < f
  | list { Term, BinaryOp, Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term, BinaryOp, Term }
  # ( a < b ) || c < d || e < f
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, Term, BinaryOp, Term }
  # a < b || ( c < d ) || e < f
  | list { Term, BinaryOp, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryOp, Term }
  # a < b || c < d || ( e < f )
  | list { Term, BinaryOp, Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }
  # ( a < b ) || ( c < d ) || e < f
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, Term, BinaryOp, Term }
  # ( a < b ) || c < d || ( e < f )
  | list { LParen, Term, BinaryOp, RParen, Term, BinaryConjunction, Term, BinaryOp, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }
  # a < b || ( c < d ) || ( e < f )
  | list { Term, BinaryOp, Term, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }
  # ( a < b ) || ( c < d ) || ( e < f )
  | list { LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen, BinaryConjunction, LParen, Term, BinaryOp, Term, RParen }

ExpressionSpecialCaseTerms =
  empty


# ********** HB **********
HBType-Condition =
  Expression
  
